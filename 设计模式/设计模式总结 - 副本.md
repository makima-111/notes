---
typora-root-url: ..\img
---

# 设计模式总结

## 一、概览

## 二、创建型

### 1、AbstractFactory 抽象工厂模式

#### 意图

提供一个创建一系列相关或相互依赖对象的接口，而无需指定具体的类。

#### 动机

支持多种视觉风格的用户界面工具包。保证风格标准间的可移植性。

#### 适用性

* 一个系统要独立与他的产品创建、组合和表示时。
* 一个系列要由多个产品系列中的一个来配置时。
* 当你要强调一系列相关的产品对象的设计以便进行联合使用时。
* 当你提供一个产品类库，而只想显示它们的接口而不是全部实现时。

#### 结构

![1624406711959](/1624406711959.png)

* AbstractFactory 声明一个创建抽象产品的操作接口
* ConcreteFactory 实现常见具体产品对象的操作
* AbstractProduct 为一类产品对象声明一个接口
* ConcreteProduct 产品对象
* Client 仅使用Abustract接口

#### 效果

1. 分离了使用者和具体类
2. 易于交换产品系列
3. 有利于产品的一致性
4. 难以支持心中类产品：需要重写所有工厂类

#### 实现

1. 将工厂作为单例
2. AbstractFactory仅声明一个创建产品的接口，每个产品定义一个工厂方法。
3. 定义可扩展工厂：AbstractFactory仅提供一个接口，接口接受参数，根据参数确定创建的类型。需要使用类型转换，有一定风险。

#### 相关模式

AbstractFactory类通常用工厂方法实现，也可以用原型方法实现。具体的工厂通常是单例。

### 2、BUILDER 生成器

#### 意图

分离复杂对象的构建与表示。

* 构建：类的创建和构成方式
* 表示：具体的成果、效果

#### 动机

阅读器应能将RTF转换为多种正文格式。深度学习框架中模型的构建。

#### 适用性

* 当**创建复杂对象的算法**需要独立于**对象的组成部分和它们的装配方式**时
* 当构造过程必须允许被构造的对象有不同的表示时。

#### 结构

![builder](/builder.png)

#### 参与者

* Builder：
  * 为创建一个对象的各个部件指定抽象接口
* ConcreteBuilder：
  * 实现Builder接口创建对象
  * 定义它所常见的实例
  * 提供一个GET接口
* Director
  * 构造一个使用Builder接口的对象
* Product
  * 被构造的复杂对象
  * 包含定义组成部件的类，和装配成最终产品的接口

#### 协作

![builder-1](/builder-1.png)

#### 效果

1. 可以通过定义新的生成器，改变一个产品的内部表示。
2. 将构造代码和表示代码分开，提高了代码复用性。
3. 更精细的控制构造过程，Director控制Builder一步一步构成对象，最后才取出。

#### 相关模式

Builder和AbstractFactory相似，都可以创建复杂对象。Builder强调一步步构造复杂对象，AbstractFactory强调多个系列对象的创建。

Composite通常是用Builder生成的。



### 3、FACTORY METHOD 工厂方法

#### 意图

定义一个用于创建对象的接口，让子类决定实例化哪一个类。将类的实例化延迟到其子类。

**用一个独立的操作创建对象，这样子类才能重新定义他们的创建方式。**

#### 动机

在一个框架中，互相作用的抽象类不知道对方的具体实现。因此在一个抽象类的子类中实例化另一个抽象类的子类。这样他们就能够知道对方的信息了。创建另一个子类的方法就是工厂方法。

#### 适用性

* 当**一个类**不知道**它所必须创建的对象的类**的时候
* 当**一个类**希望由**他的子类**来指定**它所创建的对象**的时候
* 当类将常见对象的职责委托给多个帮助子类中的一个，并且希望哪个帮助子类是代理者。

#### 结构

![factory-a](/factory-a.png)

#### 参与者

* Product
  * 对象接口
* ConcreteProduct
  * 对象
* Creator
  * 声明工厂方法，该方法返回Product对象
  * 可以调用工厂方法创建一个Product
* ConcreteCreator
  * 重新定义工厂方法

#### 效果

* 为子类提供挂钩，方便扩展。
* 连接平行的类层次

![factory-b](/factory-b.png)

#### 实现

* 普通模式
* 参数化工厂：根据传入参数，创建对应子类。
* 模板：创建时传入模板，根据模板创建对象，避免过多的创建子工厂类

#### 相关模式

* AbstractFactory经常用工厂方法实现。
* 工厂方法常在TemplateMethods中被调用
* Prototypes不需要创建Creator的子类，但需要针对Product类的初始化操作。FactoryMethod不需要初始化操作。

### 4、PROTOTYPE 原型模式

#### 意图

用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。

#### 动机

通过拷贝修改对象，避免创建过多子类。

#### 适用性

* 当一个系统应该独立于它的产品创建、构成和表示时
* 当要实例化的类是在运行时刻指定时（动态加载）
* 为了避免创建一个与产品类层次平行的工厂类层次时
* 一个类的实例只能有几个不同状态组合中的一种时

#### 结构

![3.4-prototype](/3.4-prototype.png)

#### 参与者

* Prototype
  * 生命一个克隆自身的接口
* ConcretePrototype
  * 实现克隆
* Client
  * 让一个原型克隆自身从而创建一个新的对象

#### 效果

* 对客户隐藏了具体的产品类，方便改变。
* 运行时增加或删除产品
* 改变值以指定新对象，减少子类数量。
* 改变结构以指向新对象 ，将一个组合看作原型，实现组合级别的拷贝服用。
* 用类动态配置应用

#### 实现

1. 原型管理器，类似word视图管理，客户给出关键字，原型管理器根据关键字返回原型，实现动态生成。
2. 实现克隆操作，深拷贝和浅拷贝问题。
3. 初始化克隆对象，克隆后根据需求初始化类。

### 5、SINGLETON 单例模式

#### 意图

保证一个类仅有一个实例。

#### 动机

对于一些类，只有一个实例是很重要的。可能是出于安全或性能的考虑。

#### 适用性

* 当类只能有一个实例而且客户可以从一个全局访问点访问它时。
* 当这个唯一实例应该时通过子类化可扩展的，并且客户应该无需更改代码就能使用扩展的实例时。

#### 结构

## 三、结构型模式

### 1、ADAPTER 适配器模式（有点没看懂）

#### 意图

将一个类的接口转为另一个接口，使得原本接口不兼容的对象类可以一起工作。

#### 动机

为复用现有工具类，当接口不兼容时，创建新的类作为转接。

#### 适用性

* 想使用一个已经存在的类，而接口不符合需求
* 想创建一个复用的类，该类可以与其他不相关的类协同工作
* 使用一个已存在的类，但不可能对每一个都进行子类化以匹配接口。

#### 结构

![adapter](/adapter.png)

#### 参与者

* target
  * 定义Client使用的与特定领域相关的接口
* Adaptee
  * 一个已经存在的接口，需要适配
* Adapter
  * 一个对Adaptee的接口和Target接口进行适配

#### 协作

Client在Adapter上调用一些操作，适配器通过Adaptee的操作实现

#### 效果

类适配器：

* 无法适配Adaptee子类
* 可以重新定义Adaptee行为
* 不需要额外变量指向对象

对象适配器

* 允许一个Adapter与多个Adaptee和子类一同工作
* 难以重新定义Adapter行为，需要实现Adapter子类。

双向适配器

* 在两个接口差距较大时使用。

#### 实现

Adapter应该是Target的子类

### 2、BRIDGE 桥接

#### 意图

将抽象部分与他的实现部分分离，使他们都可以独立的变化。

#### 适用性

* 不希望抽象和它的实现部分之间有一个固定的绑定关系。（运行时，实现可以被切换）
* 类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充
* 对一个抽象的实现的部分修改应该对客户不产生影响
* 减少类的生成

#### 结构

![bridge-1](/bridge-1.png)

#### 参与者

* Abstraction
  * 定义抽象类的接口
  * 维护一个指向Implementor对象的接口
* RefinedAbstraction
  * 扩充由Abstraction定义的接口
* Implementaor
  * 定义一个实现类的接口，仅提供基础操作，Abstraction提供高层次操作
* ConcreteImplementor
  * 实现Implementor

#### 协作

Abstaction将请求转发给Implementor对象

#### 效果

* 分离接口及其实现部分
* 提高可扩充性
* 实现细节对用户透明

#### 实现

* 如果只有一个Implementor 可以不使用接口
* 正确创建Implementor
  * 传入参数
  * 使用全局工厂对象（Abstract Factory），这个对象封装平台细节。

### 3、COMPOSITE 组合

#### 意图

将对象组合成树形结构以表示整体与部分的层次结构。

#### 动机

模式你的关键是一个抽象类，它既可以代表类，也可以代表类的组合。

#### 适用性

* 你想表示对象的部分-整体层结构
* 希望用户忽略对象与单个对象的不同

#### 结构

![composite](/composite.png)

####  参与者

* Component
  * 为组合中的对象声明接口
  * 实现所有类共有接口的缺省行为
  * 声明一个接口接口用于访问和管理子组件
  * 在递归结构中定义父组件
* Leaf
  * 在组合中表示叶节点对象，叶节点没有子节点
* Composite
  * 定义子部件的那些不部件行为
  * 存储子部件
  * 在Component接口中实现与子部件有关的操作
* Client
  * 通过Component接口操作组合部件的对象

#### 协作

* 用户使用Component类接口与组合结构中的对象进行交互。
* 如果接收的是叶节点，则直接处理请求。
* 如果是组合，则做相应操作。

#### 效果

* 定义了组合递归层次结构
* 简化了客户代码
* 更容易新增新的类型组件
* 不能用类型系统限制组件组成

#### 实现

* 增加父部件引用，方便操作。
* 共享组件（多个父部件）
* 最大化Component接口，尽可能多定义操作
* 子部列表
* 子部排序
* 树相关的缓存信息
* Component删除子部

#### 相关模式

通常部件-父部件连接用Responsibility of Chain

Decorator经常与Composite一起使用

Flayweight让你共享组件

Itertor可用来便利

Visitor将本来分布在Composite和leaf类中的操作和行为局部化

### 4、DECORATOR 装饰/包装器

#### 意图

动态的给对象添加职责

#### 适用性

* 在不影响其他对象的情况下，为单个对象添加职责。
* 处理那些可撤销的职责
* 当不能采用生成子类的方法进行扩充时。

![decorator](/decorator.png)

#### 参与者

* Component
  * 定义一个对象接口，可以给对象动态添加职责
* ConcreteComponent
  * 实现接口
* Decorator
  * 维持一个指向Component的指针
* ConcreteDecorator
  * 将请求转发给他的Component对象，并附加动作。

#### 效果

* 比静态继承更灵活
* 避免在层次结构高层的类有太多特征
* 有许多小对象

#### 实现

* 接口的一致性
* 只需要一个职责时可以省略抽象Decorator
* 保持Component的简单

#### 相关模式

* 与Composite不同，装饰模式目的不在于对象的聚合
* Strategy策列模式：用一个装饰你可以改变对象外形，而Strategy可以改变内核。在对象比较复杂的时候应采用Strategy。

## 四、

### 2、COMMAND 命令

#### 意图

将一个请求封装成一个对象，从而使可用不痛的请求对客户进行参数化。

#### 适用性

* 抽象出待执行的动作以参数化某对象
* 在不同的时刻指定、排列和执行请求
* 支持取消操作
* 支持修改日志
* 提供了对事务的建模方法

#### 结构

![4.2.1](/4.2.1.png)

#### 参与者

* Command
  * 声明执行操作的接口
* ConcreteCommand
  * 将一个接收者对象绑定于一个动作
  * 调用接收者相应的操作，以实现Execute
* Client
  * 创建一个具体命令对象并设定他的接收者

* Invoker
  * 要求该命令执行这个请求
* Receiver
  * 知道如何实施与执行一个请求相关的操作。

#### 协作

* Clinet创建一个ConcreteCommand对象并指定他的Receiver对象
* 某Invoker对象存储该ConcreteCommand对象
* 该Invoker对象调用Command的Execute操作提交一个请求。
* ConcreteCommand对象对调用他的Receiver的一些操作以执行该请求。![4.2.2](/4.2.2.png)

