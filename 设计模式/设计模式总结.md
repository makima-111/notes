---
typora-root-url: ..\img
---

# 设计模式总结

## 一、概览

## 二、创建型

### 1、AbstractFactory 抽象工厂模式

#### 意图

提供一个创建一系列相关或相互依赖对象的接口，而无需指定具体的类。

#### 动机

支持多种视觉风格的用户界面工具包。保证风格标准间的可移植性。

#### 适用性

* 一个系统要独立与他的产品创建、组合和表示时。
* 一个系列要由多个产品系列中的一个来配置时。
* 当你要强调一系列相关的产品对象的设计以便进行联合使用时。
* 当你提供一个产品类库，而只想显示它们的接口而不是全部实现时。

#### 结构

![1624406711959](/1624406711959.png)

* AbstractFactory 声明一个创建抽象产品的操作接口
* ConcreteFactory 实现常见具体产品对象的操作
* AbstractProduct 为一类产品对象声明一个接口
* ConcreteProduct 产品对象
* Client 仅使用Abustract接口

#### 效果

1. 分离了使用者和具体类
2. 易于交换产品系列
3. 有利于产品的一致性
4. 难以支持心中类产品：需要重写所有工厂类

#### 实现

1. 将工厂作为单例
2. AbstractFactory仅声明一个创建产品的接口，每个产品定义一个工厂方法。
3. 定义可扩展工厂：AbstractFactory仅提供一个接口，接口接受参数，根据参数确定创建的类型。需要使用类型转换，有一定风险。

#### 相关模式

AbstractFactory类通常用工厂方法实现，也可以用原型方法实现。具体的工厂通常是单例。

### 2、BUILDER 生成器

#### 意图

分离复杂对象的构建与表示。

* 构建：类的创建和构成方式
* 表示：具体的成果、效果

#### 动机

阅读器应能将RTF转换为多种正文格式。深度学习框架中模型的构建。

#### 适用性

* 当**创建复杂对象的算法**需要独立于**对象的组成部分和它们的装配方式**时
* 当构造过程必须允许被构造的对象有不同的表示时。

#### 结构

![builder](/builder.png)

#### 参与者

* Builder：
  * 为创建一个对象的各个部件指定抽象接口
* ConcreteBuilder：
  * 实现Builder接口创建对象
  * 定义它所常见的实例
  * 提供一个GET接口
* Director
  * 构造一个使用Builder接口的对象
* Product
  * 被构造的复杂对象
  * 包含定义组成部件的类，和装配成最终产品的接口

#### 协作

![builder-1](/builder-1.png)

#### 效果

1. 可以通过定义新的生成器，改变一个产品的内部表示。
2. 将构造代码和表示代码分开，提高了代码复用性。
3. 更精细的控制构造过程，Director控制Builder一步一步构成对象，最后才取出。

#### 相关模式

Builder和AbstractFactory相似，都可以创建复杂对象。Builder强调一步步构造复杂对象，AbstractFactory强调多个系列对象的创建。

Composite通常是用Builder生成的。



### 3、FACTORY METHOD 工厂方法

#### 意图

定义一个用于创建对象的接口，让子类决定实例化哪一个类。将类的实例化延迟到其子类。

**用一个独立的操作创建对象，这样子类才能重新定义他们的创建方式。**

#### 动机

在一个框架中，互相作用的抽象类不知道对方的具体实现。因此在一个抽象类的子类中实例化另一个抽象类的子类。这样他们就能够知道对方的信息了。创建另一个子类的方法就是工厂方法。

#### 适用性

* 当**一个类**不知道**它所必须创建的对象的类**的时候
* 当**一个类**希望由**他的子类**来指定**它所创建的对象**的时候
* 当类将常见对象的职责委托给多个帮助子类中的一个，并且希望哪个帮助子类是代理者。

#### 结构

![factory-a](/factory-a.png)

#### 参与者

* Product
  * 对象接口
* ConcreteProduct
  * 对象
* Creator
  * 声明工厂方法，该方法返回Product对象
  * 可以调用工厂方法创建一个Product
* ConcreteCreator
  * 重新定义工厂方法

#### 效果

* 为子类提供挂钩，方便扩展。
* 连接平行的类层次

![factory-b](/factory-b.png)

#### 实现

* 普通模式
* 参数化工厂：根据传入参数，创建对应子类。
* 模板：创建时传入模板，根据模板创建对象，避免过多的创建子工厂类

#### 相关模式

* AbstractFactory经常用工厂方法实现。
* 工厂方法常在TemplateMethods中被调用
* Prototypes不需要创建Creator的子类，但需要针对Product类的初始化操作。FactoryMethod不需要初始化操作。

### 4、PROTOTYPE 原型模式

#### 意图

用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。

#### 动机

通过拷贝修改对象，避免创建过多子类。

#### 适用性

* 当一个系统应该独立于它的产品创建、构成和表示时
* 当要实例化的类是在运行时刻指定时（动态加载）
* 为了避免创建一个与产品类层次平行的工厂类层次时
* 一个类的实例只能有几个不同状态组合中的一种时

#### 结构

![3.4-prototype](/3.4-prototype.png)

#### 参与者

* Prototype
  * 生命一个克隆自身的接口
* ConcretePrototype
  * 实现克隆
* Client
  * 让一个原型克隆自身从而创建一个新的对象

#### 效果

* 对客户隐藏了具体的产品类，方便改变。
* 运行时增加或删除产品
* 改变值以指定新对象，减少子类数量。
* 改变结构以指向新对象 ，将一个组合看作原型，实现组合级别的拷贝服用。
* 用类动态配置应用

#### 实现

1. 原型管理器，类似word视图管理，客户给出关键字，原型管理器根据关键字返回原型，实现动态生成。
2. 实现克隆操作，深拷贝和浅拷贝问题。
3. 初始化克隆对象，克隆后根据需求初始化类。

### 5、SINGLETON 单例模式

#### 意图

保证一个类仅有一个实例。

#### 动机

对于一些类，只有一个实例是很重要的。可能是出于安全或性能的考虑。

#### 适用性

* 当类只能有一个实例而且客户可以从一个全局访问点访问它时。
* 当这个唯一实例应该时通过子类化可扩展的，并且客户应该无需更改代码就能使用扩展的实例时。

#### 结构

## 三、结构型模式

### 1、ADAPTER 适配器模式

#### 意图

将一个类的接口转为另一个接口，使得原本接口不兼容的对象类可以一起工作。

#### 动机

为复用现有工具类，当接口不兼容时，创建新的类作为转接。

#### 适用性

* 想使用一个已经存在的类，而接口不符合需求
* 想创建一个复用的类，该类可以与其他不相关的类协同工作
* 使用一个已存在的类，但不可能对每一个都进行子类化以匹配接口。

#### 结构

![adapter](/adapter.png)

#### 参与者

* target
  * 定义Client使用的与特定领域相关的接口
* Adaptee
  * 一个已经存在的接口，需要适配
* Adapter
  * 一个对Adaptee的接口和Target接口进行适配

#### 协作

Client在Adapter上调用一些操作，适配器通过Adaptee的操作实现

#### 效果

类适配器：

* 无法适配Adaptee子类
* 可以重新定义Adaptee行为
* 不需要额外变量指向对象

对象适配器

* 允许一个Adapter与多个Adaptee和子类一同工作
* 难以重新定义Adapter行为，需要实现Adapter子类。

双向适配器

* 在两个接口差距较大时使用。

#### 实现

Adapter应该是Target的子类

### 2、BRIDGE 桥接

#### 意图

将抽象部分与他的实现部分分离，使他们都可以独立的变化。

#### 适用性

* 不希望抽象和它的实现部分之间有一个固定的绑定关系。（运行时，实现可以被切换）
* 类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充
* 对一个抽象的实现的部分修改应该对客户不产生影响
* 减少类的生成

#### 结构

![bridge-1](/bridge-1.png)

#### 参与者

* Abstraction
  * 定义抽象类的接口
  * 维护一个指向Implementor对象的接口
* RefinedAbstraction
  * 扩充由Abstraction定义的接口
* Implementaor
  * 定义一个实现类的接口，仅提供基础操作，Abstraction提供高层次操作
* ConcreteImplementor
  * 实现Implementor

#### 协作

Abstaction将请求转发给Implementor对象

#### 效果

* 分离接口及其实现部分
* 提高可扩充性
* 实现细节对用户透明
* **实现系统可能有多个角度分类，每一种分类都有可能变化，那就把这种多角度分离出来让他们独立变化，减少耦合。**

#### 实现

* 如果只有一个Implementor 可以不使用接口
* 正确创建Implementor
  * 传入参数
  * 使用全局工厂对象（Abstract Factory），这个对象封装平台细节。

### 3、COMPOSITE 组合

#### 意图

将对象组合成树形结构以表示整体与部分的层次结构。

#### 动机

模式你的关键是一个抽象类，它既可以代表类，也可以代表类的组合。

#### 适用性

* 你想表示对象的部分-整体层结构
* 希望用户忽略对象与单个对象的不同

#### 结构

![composite](/composite.png)

####  参与者

* Component
  * 为组合中的对象声明接口
  * 实现所有类共有接口的缺省行为
  * 声明一个接口接口用于访问和管理子组件
  * 在递归结构中定义父组件
* Leaf
  * 在组合中表示叶节点对象，叶节点没有子节点
* Composite
  * 定义子部件的那些不部件行为
  * 存储子部件
  * 在Component接口中实现与子部件有关的操作
* Client
  * 通过Component接口操作组合部件的对象

#### 协作

* 用户使用Component类接口与组合结构中的对象进行交互。
* 如果接收的是叶节点，则直接处理请求。
* 如果是组合，则做相应操作。

#### 效果

* 定义了组合递归层次结构
* 简化了客户代码
* 更容易新增新的类型组件
* 不能用类型系统限制组件组成

#### 实现

* 增加父部件引用，方便操作。
* 共享组件（多个父部件）
* 最大化Component接口，尽可能多定义操作
* 子部列表
* 子部排序
* 树相关的缓存信息
* Component删除子部

#### 相关模式

通常部件-父部件连接用Responsibility of Chain

Decorator经常与Composite一起使用

Flayweight让你共享组件

Itertor可用来便利

Visitor将本来分布在Composite和leaf类中的操作和行为局部化

### 4、DECORATOR 装饰/包装器

#### 意图

动态的给对象添加职责

#### 适用性

* 在不影响其他对象的情况下，为单个对象添加职责。
* 处理那些可撤销的职责
* 当不能采用生成子类的方法进行扩充时。

![decorator](/decorator.png)

#### 参与者

* Component
  * 定义一个对象接口，可以给对象动态添加职责
* ConcreteComponent
  * 实现接口
* Decorator
  * 维持一个指向Component的指针
* ConcreteDecorator
  * 将请求转发给他的Component对象，并附加动作。

#### 效果

* 比静态继承更灵活
* 避免在层次结构高层的类有太多特征
* 有许多小对象

#### 实现

* 接口的一致性
* 只需要一个职责时可以省略抽象Decorator
* 保持Component的简单

#### 相关模式

* 与Composite不同，装饰模式目的不在于对象的聚合
* Strategy策列模式：用一个装饰你可以改变对象外形，而Strategy可以改变内核。在对象比较复杂的时候应采用Strategy。

### 5、FACADE外观模式

#### 意图

* 为子系统的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使子系统更容易使用

![3.5](/3.5.png)

#### 适用性

* 为一个一个复杂子系统提供一个简单的接口，避免过度定制化导致用户难以上手。类似自动配置。
* 提高系统的分离性
* 当需要构建一个层次结构的子系统时，使用facade模式定义子系统中每层的入口点。

#### 结构

![3.5.1](/3.5.1.png)

#### 参与者

* Facade
  * 知道那些子系统类负责处理请求
  * 将客户请求代理给适当的子系统
* Subsystemclassess
  * 实现功能
  * 处理Facade指派的任务

#### 效果

* 对客户屏蔽子系统组件，更方便使用。
* 实现了子系统和客户之间的松耦合关系，子系统内部的功能组件往往时紧耦合的。

#### 实现

1. 降低耦合：用抽象类实现Facade，各个子系统分别实现具体Facade。或者用子系统配置Facade对象。
2. 公共子系统和私有子系统：考虑公共和私有系统接口，面向对象语言不太支持。

### 6、FLYWEIGHT享元

#### 意图

用共享技术有效的支持大量细粒度的对象。

#### 动机

在文本编辑器视线中，每一个字符只有一个实际的对象，他在个位置共享。

#### 适用性

* 有大量对象
* 完全使用大量对象会造成很大的存储开销
* 对象的大多数状态都是可变的外部状态（可以从对象中提出）
* 如果删除外部状态，那么可以用少量共享对象取代很多组对象
* 程序不依赖对象表示

#### 结构

![3.6.1](/3.6.1.png)

![3.6.2](/3.6.2.png)

#### 参与者

* Flyweight
  * 描述一个接口，通过这个接口flyweight可以接受并作用于外部状态。
* ConcreteFlyweight
  * 实现接口，并为内部状态增加存储空间，必须可共享。
* UnsharedConcreteFlyweight
  * 实现接口，不可共享。
* FlyweightFactory
  * 创建并管理flyweigth对象
* Client
  * 维持对flyweight的引用
  * 存储外部状态

#### 效果

* 查找会有额外开销，但空间上会节省很多。
* 经常和Composite结合成一个层次模式。叶节点时共享的。

### 7、PROXY代理

#### 意图

为其他对象提供一种代理以控制对这个对象的访问。

#### 适用性

* 远程代理：为一个对象在不同的地址空间提供局部代表
* 虚代理：代理对象可以作为一些重量级对象的占位符，在真正需要的时候才加载实际对象。
* 保护代理，控制对象访问。
* 智能指引：在访问时附加操作，例如计数等等。

#### 结构

![3.7.1](/3.7.1.png)

![3.7.2](/3.7.2.png)

#### 参与者

* Proxy
  * 保存一个引用使得代理可以访问实体。
  * 提供一个于subject的接口相同的接口，这样就可以代替实体。
  * 控制对实体的存取
  * 各类型：
    * 远程代理：负责对请求编码，向远程发送请求。
    * 虚代理：缓存实体附加信息，以便延迟访问呢。
    * 保护代理：检查调用者权限。
* Subject
  * 定义共用接口
* RealSubject
  * 实体

#### 效果

* Remote Proxy 瓶坯不同地址空间这一事实
* Virtual Proxy 进行最优化
* Protection Proxies 附加操作

### 8、相关性

#### Adapter与Bridge

相同点：

* 都给另一个对象提供了一定程度上的间接性
* 有利于系统灵活
* 转发请求

不同点：

* 使用阶段：Adapter是粗线不可预见时耦合使用，Bridge是在于见到有耦合时使用。
* 时间：Adapter在类设计好之前使用，Bridge在之后。
* 用途：Adapter解决两个已有类的接口不匹配问题；Bridge对抽象接口与他的可能的实现部分进行桥接。

#### Composite、Decorator与Proxy

Composite与Decorator类似，都可以递归组合，但是目的不同。Decorator目标是在不产生子类的情况下，增加对象的职责。Composite目的是构造类，使多个相关对象能够以统一的方式处理。

两者功能互补，通常协同使用。

Proxy不能递归或增加职责，它强调一种代理关系。

## 四、行为模式

### 1、CHAIN OF RESPONSIBILITY 职责链

#### 意图

使多个对象都有机会处理请求，将这些对象连成一条链，并沿着链条传递请求，知道有一个对象处理它为止。

#### 适用性

* 有多个对象可以处理一个请求，那个对象处理请求运行时刻自动确认。
* 想在不确定接收者的情况下，向多个对象中的一个提交请求。
* 可处理一个请求的对象几何应被动态指定。

#### 结构

![4.1.1](/4.1.1.png)

#### 参与者

* Handler
  * 定义一个处理请求的接口
  * 实现后续链
* ConcreteHandler
  * 处理负责的请求
  * 可访问他的后继者
  * 处理请请求或转发
* Client
  * 向链上一个具体对象提交请求。

#### 效果

* 降低耦合：不需要知道哪个对象处理其请求。只需要知道会被正确处理。
* 增强了灵活性：可以在运行时动态修改链
* 不保证接受：不保证请求一定被处理。

### 2、COMMAND命令

#### 意图

将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。

#### 适用性

当有如下需求时，可用command模式：

* 需要类似回调
* 在不同的时刻指定、排列和执行请求。command对象可以有一个与初始请求无关的生存周期。
* 支持取消操作。
* 支持修改日志，崩溃恢复。
* 提供了对事务进行建模的方法。

#### 结构

![4.2.1](/4.2.1.png)

#### 参与者

* Command
  * 声明执行操作的接口
* ConcreteCommand
  * 将一个接收者对象绑定于一个动作
  * 调用接收者的相应操作以实现Execute
* Client
  * 创建于给具体命令对象并设定他的接收者
* Invoker
  * 要求该命令执行这个请求
* Receiver
  * 知道如何试试与操作一个请求相关操作

#### 协作

* Client创建一个ConcreteCommand对象并指定Receiver
* 某Invoker对象存储该ConcreteCommand对象
* 该Invoker通过调用Command对象的Execute操作提交请求
* Concrete Command对象对调用它的Receiver的一些操作以执行该请求。

![4.2.2](/4.2.2.png)

#### 效果

1. Command模式将调用操作的对象与知道如何实现该操作的对象解耦
2. Command时头等的对象，他们可以被操作和扩展
3. 多个命令可以组合成复合命令
4. 实现新的Command很容易。

### 3、ITERATOR 迭代器

#### 意图

提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露对象的内部表示

#### 适用性

* 访问呢一个聚合对象的内容而无需暴露他的内部表示
* 支持对聚合对象的多种遍历
* 为遍历不同的聚合结构提供一个统一的接口

#### 结构

![4.3.1](/4.3.1.png)

#### 参与者：

* Iterator
  * 迭代器定义访问和遍历元素的接口
* ConcreteIterator
  * 实现接口
  * 跟踪当前位置
* Aggreate
  * 聚合定义创建相应迭代器对象的接口
* ConcreteAggregate
  * 实现接口，返回ConcreteIterator对象

#### 效果

* 支持以不同的方式遍历一个集合
* 简化了聚合的接口
* 在一个聚合上可以有多个便利

#### 实现

* 谁控制迭代：外部迭代器：客户控制迭代。内部迭代：迭代器控制。外部功能更强。
* 谁定义遍历算法：聚合体和迭代器都可以
* 健壮程度：遍历的同时修改会发生什么

### 4、MEDIATOR 中介者

#### 意图

用一个中介对象来封装一系列的对象交互。中介者是个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变他们之间的交互。

#### 适用性

* 一组对象以定义良好但是复杂的方式进行通信，产生依赖结构混乱难以整理。
* 一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用。
* 想定制一个分布在多个类中的行为，而不想生成太多子类。

#### 结构

![4.4.1](/4.4.1.png)

#### 参与者

* Mediator
  * 中介者定义一个接口用于与个同事对象通信
* ConcreteMediator
  * 实现接口，协调各同时协作行为
  * 了解并维护他的各个同事
* Colleague
  * 每一个同事类都知道他的中介者对象
  * 每一个同时对象在需与其他的同时通信的时候，与他的中介者通信

![4.4.2](/4.4.2.png)

#### 效果

* 减少了子类生成
* 将各Colleague解耦
* 简化了对象协议，从C-C的n对n关系变为M-C的1对n关系
* 将对象如何协作进行了抽象
* 使控制集中化

### 5、MEMENTO备忘录

#### 意图

在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。

这样以后就可以将该对象恢复到原先保存的状态。

#### 适用性

* 必须保存一个对象在某一时刻的状态，以便恢复
* 用一个接口来让其他对象直接得到这些状态，将会暴露对象的实现细节并破坏封装

#### 结构

![4.5.1](/4.5.1.png)

#### 参与者

* Memento
  * 备忘录存储原发器对象的内部状态。原发器根据需要决定备忘录存储原发器的那些内部状态
  * 防止原发器以外的对象访问备忘录。
* Originator原发器
  * 创建一个备忘录并记录内部状态
  * 用备忘录恢复内部状态
* Caretaker
  * 负责保存备忘录
  * 不操作备忘录

#### 协作

![4.5.2](/4.5.2.png)

#### 效果

* 保持封装边界
* 简化了原发器
* 使用备忘录可能有很高代价：存储信息
* 定义宽、窄接口
* 维护备忘录的代价

### 6、观察者

#### 意图

定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖与它的对象都得到通知并被自动更新。

#### 适用性

* 当一个抽象模型有两个方面，其中一个方面依赖另一个方面。将这二者封装在独立的对象中以使他们可以各自独立地改变和复用。
* 当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变。
* 当一个对象必须通知其他对象，而它又不能假定其他对象是谁

#### 结构

![4.6.1](/4.6.1.png)

#### 参与者

* Subject（目标）
  * 目标知道他的观察者。可以有多个观察者观察同一目标
  * 提供注册和删除观察者接口
* Observer（观察者）
  * 为那些目标发生改变时需要获得统治的对象定义一个更新接口
* ConcreteSubject（具体目标）
  * 将有关状态存入各ConcreteObserver对象
  * 当它的状态发生改变时，向各个观察者发出通知
* ConcreteObserver（具体观察者）
  * 维护一个指向ConcreteSubject对象的引用
  * 存储有关状态，这些状态应与目标的状态保持一致
  * 实现Observer的更新接口以使自身状态与目标状态保持一致

#### 协作

![4.6.2](/4.6.2.png)

#### 效果

1. 目标和观察者间的抽象耦合。目标不知道观察者属于哪一个具体类。
2. 支持广播通信

### 7、STATE 状态

#### 意图

允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。

#### 适用性

* 一个对象的行为决定于它的状态，并且它必须在运行时刻根据状态改变它的行为
* 一个操作中含有庞大的分支条件语句，且这些分支依赖于该对象状态。

#### 结构

![4.7.1](/4.7.1.png)

#### 参与者

* Context
  * 定义客户感兴趣的接口
  * 维护一个ConcreteState子类的实例，这个实例定义当前状态
* State
  * 定义一个接口以封装与Context的一个特定状态相关的行为
* ConcreteState subclasses
  * 每一个子类实现一个与Context的一个状态相关的行为

#### 协作

* Context将与状态相关的请求委托给当前ConcreteState对象处理
* COntext可将自身作为一个参数传递给处理该请求的状态对象，这使得状态对象在必要时可访问Context
* Context时客户使用的主要接口。客户可用状态对象来配置一个Context，配置完后，用户便不与状态对象直接打交道
* Context或ConcreteState子类都可以决定那个状态的转换。

#### 效果

* 将与特定状态相关的行为局部化，并且将不同状态的行为分割开来
* 它使得状态转换显示化
* State对象可被共享

### 8、STRATEGY 策略

#### 意图

定义一系列的算法，把他们一个个封装起来，并且使他们可相互替换。

#### 适用性

* 许多相关的类仅仅使行为有异。策略提供了一种用多个行为中的一个行为来配置一个类的方法。
* 需要使用一个算法的不同变体。
* 避免暴露复杂的与算法相关的数据结构
* 一个类定义了多种行为，行为以多个条件语句出现。可以替换为Strategy类。

#### 结构

![4.7.2](/4.7.2.png)

#### 参与者

* Strategy
  * 定义所有支持的算法的公共接口。Context使用这个接口来调用某ConcreteStrategy定义的算法
* ConcreteStrategy
  * 以Strategy接口实现具体算法
* Context
  * 用一个ConcreteStrategy对象来配置
  * 维护一个对Strategy对象的引用
  * 可定义一个接口来让Strategy访问它的数据。

#### 效果

* 相关算法系列：定义了一系列可替换的算法。
* 一个替换继承的方法
* 消除一些条件语句
* 实现的选择
* 客户要了解不同的算法
* Strategy和Context之间的通信开销
* 增加了对象的数目 

### 9、TEMPLATE METHOD 模板方法

#### 意图

定义一个操作中的算法的骨架，而将这些步骤延迟到子类中。TemplateMethod使得子类可以不改变一个算法的的结构即可重定义该算法的某些特定步骤。

#### 适用性

* 一次性实现一个算法的不变部分，并将可变的行为留给子类来实现。
* 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。
* 控制子类扩展。模板方法只在特定点调用“hook”操作，这样就允许在这些点进行扩展

#### 结构

![4.9.1](/4.9.1.png)

#### 参与者

* AbstractClass
  * 定义抽象的原语操作，具体的子类将重定义他们以实现一个算法的各步骤。
  * 实现一个模板方法定义一个算法骨架。该模板方法不仅调用原语操作，也调用定义在AbstractClass或其他对象中的操作。
* ConcreteClass
  * 实现源于操作以完成算法中与特定子类相关的步骤。

#### 效果

