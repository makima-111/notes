---
typora-root-url: ..\img
---

# 设计模式总结

## 一、概览

## 二、创建型

### 1、AbstractFactory 抽象工厂模式

#### 意图

提供一个创建一系列相关或相互依赖对象的接口，而无需指定具体的类。

#### 动机

支持多种视觉风格的用户界面工具包。保证风格标准间的可移植性。

#### 适用性

* 一个系统要独立与他的产品创建、组合和表示时。
* 一个系列要由多个产品系列中的一个来配置时。
* 当你要强调一系列相关的产品对象的设计以便进行联合使用时。
* 当你提供一个产品类库，而只想显示它们的接口而不是全部实现时。

#### 结构

![1624406711959](/1624406711959.png)

* AbstractFactory 声明一个创建抽象产品的操作接口
* ConcreteFactory 实现常见具体产品对象的操作
* AbstractProduct 为一类产品对象声明一个接口
* ConcreteProduct 产品对象
* Client 仅使用Abustract接口

#### 效果

1. 分离了使用者和具体类
2. 易于交换产品系列
3. 有利于产品的一致性
4. 难以支持心中类产品：需要重写所有工厂类

#### 实现

1. 将工厂作为单例
2. AbstractFactory仅声明一个创建产品的接口，每个产品定义一个工厂方法。
3. 定义可扩展工厂：AbstractFactory仅提供一个接口，接口接受参数，根据参数确定创建的类型。需要使用类型转换，有一定风险。

#### 相关模式

AbstractFactory类通常用工厂方法实现，也可以用原型方法实现。具体的工厂通常是单例。

### 2、BUILDER 生成器

#### 意图

分离复杂对象的构建与表示。

* 构建：类的创建和构成方式
* 表示：具体的成果、效果

#### 动机

阅读器应能将RTF转换为多种正文格式。深度学习框架中模型的构建。

#### 适用性

* 当**创建复杂对象的算法**需要独立于**对象的组成部分和它们的装配方式**时
* 当构造过程必须允许被构造的对象有不同的表示时。

#### 结构

![builder](/builder.png)

#### 参与者

* Builder：
  * 为创建一个对象的各个部件指定抽象接口
* ConcreteBuilder：
  * 实现Builder接口创建对象
  * 定义它所常见的实例
  * 提供一个GET接口
* Director
  * 构造一个使用Builder接口的对象
* Product
  * 被构造的复杂对象
  * 包含定义组成部件的类，和装配成最终产品的接口

#### 协作

![builder-1](/builder-1.png)

#### 效果

1. 可以通过定义新的生成器，改变一个产品的内部表示。
2. 将构造代码和表示代码分开，提高了代码复用性。
3. 更精细的控制构造过程，Director控制Builder一步一步构成对象，最后才取出。

#### 相关模式

Builder和AbstractFactory相似，都可以创建复杂对象。Builder强调一步步构造复杂对象，AbstractFactory强调多个系列对象的创建。

Composite通常是用Builder生成的。



### 3、FACTORY METHOD 工厂方法

#### 意图

定义一个用于创建对象的接口，让子类决定实例化哪一个类。将类的实例化延迟到其子类。

**用一个独立的操作创建对象，这样子类才能重新定义他们的创建方式。**

#### 动机

在一个框架中，互相作用的抽象类不知道对方的具体实现。因此在一个抽象类的子类中实例化另一个抽象类的子类。这样他们就能够知道对方的信息了。创建另一个子类的方法就是工厂方法。

#### 适用性

* 当**一个类**不知道**它所必须创建的对象的类**的时候
* 当**一个类**希望由**他的子类**来指定**它所创建的对象**的时候
* 当类将常见对象的职责委托给多个帮助子类中的一个，并且希望哪个帮助子类是代理者。

#### 结构

![factory-a](/factory-a.png)

#### 参与者

* Product
  * 对象接口
* ConcreteProduct
  * 对象
* Creator
  * 声明工厂方法，该方法返回Product对象
  * 可以调用工厂方法创建一个Product
* ConcreteCreator
  * 重新定义工厂方法

#### 效果

* 为子类提供挂钩，方便扩展。
* 连接平行的类层次

![factory-b](/factory-b.png)

#### 实现

* 普通模式
* 参数化工厂：根据传入参数，创建对应子类。
* 模板：创建时传入模板，根据模板创建对象，避免过多的创建子工厂类

#### 相关模式

* AbstractFactory经常用工厂方法实现。
* 工厂方法常在TemplateMethods中被调用
* Prototypes不需要创建Creator的子类，但需要针对Product类的初始化操作。FactoryMethod不需要初始化操作。

### 4、PROTOTYPE 原型模式

#### 意图

用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。

#### 动机

通过拷贝修改对象，避免创建过多子类。

#### 适用性

* 当一个系统应该独立于它的产品创建、构成和表示时
* 当要实例化的类是在运行时刻指定时（动态加载）
* 为了避免创建一个与产品类层次平行的工厂类层次时
* 一个类的实例只能有几个不同状态组合中的一种时

#### 结构

![3.4-prototype](/3.4-prototype.png)

#### 参与者

* Prototype
  * 生命一个克隆自身的接口
* ConcretePrototype
  * 实现克隆
* Client
  * 让一个原型克隆自身从而创建一个新的对象

#### 效果

* 对客户隐藏了具体的产品类，方便改变。
* 运行时增加或删除产品
* 改变值以指定新对象，减少子类数量。
* 改变结构以指向新对象 ，将一个组合看作原型，实现组合级别的拷贝服用。
* 用类动态配置应用

#### 实现

1. 原型管理器，类似word视图管理，客户给出关键字，原型管理器根据关键字返回原型，实现动态生成。
2. 实现克隆操作，深拷贝和浅拷贝问题。
3. 初始化克隆对象，克隆后根据需求初始化类。

### 5、SINGLETON 单例模式

#### 意图

保证一个类仅有一个实例。

#### 动机

对于一些类，只有一个实例是很重要的。可能是出于安全或性能的考虑。

#### 适用性

* 当类只能有一个实例而且客户可以从一个全局访问点访问它时。
* 当这个唯一实例应该时通过子类化可扩展的，并且客户应该无需更改代码就能使用扩展的实例时。

#### 结构

## 三、结构型模式

### 1、ADAPTER 适配器模式（有点没看懂）

#### 意图

将一个类的接口转为另一个接口，使得原本接口不兼容的对象类可以一起工作。

#### 动机

为复用现有工具类，当接口不兼容时，创建新的类作为转接。

#### 适用性

* 想使用一个已经存在的类，而接口不符合需求
* 想创建一个复用的类，该类可以与其他不相关的类协同工作
* 使用一个已存在的类，但不可能对每一个都进行子类化以匹配接口。

#### 结构

![adapter](/adapter.png)

#### 参与者

* target
  * 定义Client使用的与特定领域相关的接口
* Adaptee
  * 一个已经存在的接口，需要适配
* Adapter
  * 一个对Adaptee的接口和Target接口进行适配

#### 协作

Client在Adapter上调用一些操作，适配器通过Adaptee的操作实现

#### 效果

类适配器：

* 无法适配Adaptee子类
* 可以重新定义Adaptee行为
* 不需要额外变量指向对象

对象适配器

* 允许一个Adapter与多个Adaptee和子类一同工作
* 难以重新定义Adapter行为，需要实现Adapter子类。

双向适配器

* 在两个接口差距较大时使用。

#### 实现

Adapter应该是Target的子类

### 2、BRIDGE 桥接

#### 意图

将抽象部分与他的实现部分分离，使他们都可以独立的变化。

#### 适用性

* 不希望抽象和它的实现部分之间有一个固定的绑定关系。（运行时，实现可以被切换）
* 类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充
* 对一个抽象的实现的部分修改应该对客户不产生影响
* 减少类的生成

#### 结构

![bridge-1](/bridge-1.png)

#### 参与者

* Abstraction
  * 定义抽象类的接口
  * 维护一个指向Implementor对象的接口
* RefinedAbstraction
  * 扩充由Abstraction定义的接口
* Implementaor
  * 定义一个实现类的接口，仅提供基础操作，Abstraction提供高层次操作
* ConcreteImplementor
  * 实现Implementor

#### 协作

Abstaction将请求转发给Implementor对象

#### 效果

* 分离接口及其实现部分
* 提高可扩充性
* 实现细节对用户透明

#### 实现

* 如果只有一个Implementor 可以不使用接口
* 正确创建Implementor
  * 传入参数
  * 使用全局工厂对象（Abstract Factory），这个对象封装平台细节。

### 3、COMPOSITE 组合

#### 意图

将对象组合成树形结构以表示整体与部分的层次结构。

#### 动机

模式你的关键是一个抽象类，它既可以代表类，也可以代表类的组合。

#### 适用性

* 你想表示对象的部分-整体层结构
* 希望用户忽略对象与单个对象的不同

#### 结构

![composite](/composite.png)

####  参与者

* Component
  * 为组合中的对象声明接口
  * 实现所有类共有接口的缺省行为
  * 声明一个接口接口用于访问和管理子组件
  * 在递归结构中定义父组件
* Leaf
  * 在组合中表示叶节点对象，叶节点没有子节点
* Composite
  * 定义子部件的那些不部件行为
  * 存储子部件
  * 在Component接口中实现与子部件有关的操作
* Client
  * 通过Component接口操作组合部件的对象

#### 协作

* 用户使用Component类接口与组合结构中的对象进行交互。
* 如果接收的是叶节点，则直接处理请求。
* 如果是组合，则做相应操作。

#### 效果

* 定义了组合递归层次结构
* 简化了客户代码
* 更容易新增新的类型组件
* 不能用类型系统限制组件组成

#### 实现

* 增加父部件引用，方便操作。
* 共享组件（多个父部件）
* 最大化Component接口，尽可能多定义操作
* 子部列表
* 子部排序
* 树相关的缓存信息
* Component删除子部

#### 相关模式

通常部件-父部件连接用Responsibility of Chain

Decorator经常与Composite一起使用

Flayweight让你共享组件

Itertor可用来便利

Visitor将本来分布在Composite和leaf类中的操作和行为局部化

### 4、DECORATOR 装饰/包装器

#### 意图

动态的给对象添加职责

#### 适用性

* 在不影响其他对象的情况下，为单个对象添加职责。
* 处理那些可撤销的职责
* 当不能采用生成子类的方法进行扩充时。

![decorator](/decorator.png)

#### 参与者

* Component
  * 定义一个对象接口，可以给对象动态添加职责
* ConcreteComponent
  * 实现接口
* Decorator
  * 维持一个指向Component的指针
* ConcreteDecorator
  * 将请求转发给他的Component对象，并附加动作。

#### 效果

* 比静态继承更灵活
* 避免在层次结构高层的类有太多特征
* 有许多小对象

#### 实现

* 接口的一致性
* 只需要一个职责时可以省略抽象Decorator
* 保持Component的简单

#### 相关模式

* 与Composite不同，装饰模式目的不在于对象的聚合
* Strategy策列模式：用一个装饰你可以改变对象外形，而Strategy可以改变内核。在对象比较复杂的时候应采用Strategy。

### 5、FACADE外观模式

#### 意图

* 为子系统的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使子系统更容易使用

![3.5](/3.5.png)

#### 适用性

* 为一个一个复杂子系统提供一个简单的接口，避免过度定制化导致用户难以上手。类似自动配置。
* 提高系统的分离性
* 当需要构建一个层次结构的子系统时，使用facade模式定义子系统中每层的入口点。

#### 结构

![3.5.1](/3.5.1.png)

#### 参与者

* Facade
  * 知道那些子系统类负责处理请求
  * 将客户请求代理给适当的子系统
* Subsystemclassess
  * 实现功能
  * 处理Facade指派的任务

#### 效果

* 对客户屏蔽子系统组件，更方便使用。
* 实现了子系统和客户之间的松耦合关系，子系统内部的功能组件往往时紧耦合的。

#### 实现

1. 降低耦合：用抽象类实现Facade，各个子系统分别实现具体Facade。或者用子系统配置Facade对象。
2. 公共子系统和私有子系统：考虑公共和私有系统接口，面向对象语言不太支持。

### 6、FLYWEIGHT享元

#### 意图

用共享技术有效的支持大量细粒度的对象。

#### 动机

在文本编辑器视线中，每一个字符只有一个实际的对象，他在个位置共享。

#### 适用性

* 有大量对象
* 完全使用大量对象会造成很大的存储开销
* 对象的大多数状态都是可变的外部状态（可以从对象中提出）
* 如果删除外部状态，那么可以用少量共享对象取代很多组对象
* 程序不依赖对象表示

#### 结构

![3.6.1](/3.6.1.png)

![3.6.2](/3.6.2.png)

#### 参与者

* Flyweight
  * 描述一个接口，通过这个接口flyweight可以接受并作用于外部状态。
* ConcreteFlyweight
  * 实现接口，并为内部状态增加存储空间，必须可共享。
* UnsharedConcreteFlyweight
  * 实现接口，不可共享。
* FlyweightFactory
  * 创建并管理flyweigth对象
* Client
  * 维持对flyweight的引用
  * 存储外部状态

#### 效果

* 查找会有额外开销，但空间上会节省很多。
* 经常和Composite结合成一个层次模式。叶节点时共享的。

### 7、PROXY代理

#### 意图

为其他对象提供一种代理以控制对这个对象的访问。

#### 适用性

* 远程代理：为一个对象在不同的地址空间提供局部代表
* 虚代理：代理对象可以作为一些重量级对象的占位符，在真正需要的时候才加载实际对象。
* 保护代理，控制对象访问。
* 智能指引：在访问时附加操作，例如计数等等。

#### 结构

![3.7.1](/3.7.1.png)

![3.7.2](/3.7.2.png)

#### 参与者

* Proxy
  * 保存一个引用使得代理可以访问实体。
  * 提供一个于subject的接口相同的接口，这样就可以代替实体。
  * 控制对实体的存取
  * 各类型：
    * 远程代理：负责对请求编码，向远程发送请求。
    * 虚代理：缓存实体附加信息，以便延迟访问呢。
    * 保护代理：检查调用者权限。
* Subject
  * 定义共用接口
* RealSubject
  * 实体

#### 效果

* Remote Proxy 瓶坯不同地址空间这一事实
* Virtual Proxy 进行最优化
* Protection Proxies 附加操作

### 8、相关性

#### Adapter与Bridge

相同点：

* 都给另一个对象提供了一定程度上的间接性
* 有利于系统灵活
* 转发请求

不同点：

* 使用阶段：Adapter是粗线不可预见时耦合使用，Bridge是在于见到有耦合时使用。
* 时间：Adapter在类设计好之前使用，Bridge在之后。
* 用途：Adapter解决两个已有类的接口不匹配问题；Bridge对抽象接口与他的可能的实现部分进行桥接。

#### Composite、Decorator与Proxy

Composite与Decorator类似，都可以递归组合，但是目的不同。Decorator目标是在不产生子类的情况下，增加对象的职责。Composite目的是构造类，使多个相关对象能够以统一的方式处理。

两者功能互补，通常协同使用。

Proxy不能递归或增加职责，它强调一种代理关系。

## 四、行为模式

### 1、CHAIN OF RESPONSIBILITY 职责链

#### 意图

使多个对象都有机会处理请求，将这些对象连成一条链，并沿着链条传递请求，知道有一个对象处理它为止。

#### 适用性

* 有多个对象可以处理一个请求，那个对象处理请求运行时刻自动确认。
* 想在不确定接收者的情况下，向多个对象中的一个提交请求。
* 可处理一个请求的对象几何应被动态指定。

#### 结构

![4.1.1](/4.1.1.png)

#### 参与者

* Handler
  * 定义一个处理请求的接口
  * 实现后续链
* ConcreteHandler
  * 处理负责的请求
  * 可访问他的后继者
  * 处理请请求或转发
* Client
  * 向链上一个具体对象提交请求。

#### 效果

* 降低耦合：不需要知道哪个对象处理其请求。只需要知道会被正确处理。
* 增强了灵活性：可以在运行时动态修改链
* 不保证接受：不保证请求一定被处理。

